Because there is yet a real documentation to be created for QPG, I will try to
explain what it is and how it works within this short document,

QPG is a parser and lexer generator meant to replace more traditional solutions
like flex and bison. It reads in a single file containing the regular 
expressions for the lexer as well as the grammer used to generate the parser.

The output of QPG is made of two files. One being a C++ file containing the 
actual implementation of the parser and the other, a header file,  containing 
declarations you will need to include in your part of the implementation. 

The input file is split into three section. The first section consists of a 
number of #include statements, which will be copied verbatim to the output.
Examples:

#include "myheader.h"
/*produces a include directive in the output to include myheader.h*/
#include "foo.h"
//Same for foo.h

Note that only local includes are allowed. So

#include <string>

is not legal, for example. You will have to create a helper include file for
situations where you need includes like this.

Also note the use od c++-style comments in the example above. You can insert
comments like these throughout the whole input file.

In the second, optional, section of the input some options can be set and some
details of the output changed. This is done by adding lines like this

#option option_name optiona_value

Where option_name and option_value have to be replaced by a valid option name
and a valid value for that option, respectively.

The third, last and most important part of the input contains the definition
of the lexer and parser to generated. It is made of a sequence of different
types of statements in arbritrary order. The types of statements are:

1.Definition statements

  allow to bind a regular expression to a name. You can refer to these 
  definitions in later regular expression by enclosing their names in {}.
  Additionally you can define (once and before first use) the meaning of the
  dot (.) in regular expressions. It is [\u0000-\uFFFF] by default, but if
  you want to generate a parser for pure ASCII input, for example, you could 
  set it to [\0-\177]. Note, that this definition is also used to interprete
  regular expression of the form [^<characters>], which are internally 
  transformed to .-[<characters>] . (See also operator - below.)
  
  Usages:
    IDENTIFIER := REGEXP ;
    IDENTIFIER := STRING ;
    . := REGEXP ;
    
  Example:
    whitespace := /[ \n\r]+/;

2.Pattern statements

  define patterns the lexer will recognize. Patterns are defined by a regular
  expression and can optionally be tied to an action. When two or more patterns 
  match the current input token, the one declared first will be chosen. Pattern
  matching is greedy.
  Also, QPG supports the use of start conditions, a mechanism to conditionally 
  activate patterns. A pattern can be activated for several start conditions
  by placing the names of the desired start conditions in < > before the 
  pattern. Patterns with no explicitly given start conditions are considered 
  to be active only under the start condition 'INITIAL', which is the initial 
  one.
  If a pattern has an action, designated by an IDENTIFIER, then whenever the
  pattern is matched, a method with the same name will be invoked. The 
  signature of such a method "foo" would be:
  
    void foo(const String &, TokenList &)

  That means the method will be invoked with the matched part of the input as a
  string and a mutable reference to a value of type TokenList. TokenList is a
  class implementing a singly linked list of tokens, and is generated by QPG. 
  Its declaration resides in the header output file. It is supposed to be a 
  member type of your implementing class. The referenced list serves as the 
  input to the parser and is "refilled" every time the parser has used up all 
  the tokens in it by calling the lexer. 
  
  For every token type (see below) it offers a method, which appends a token of
  the respective type to the list. Usually the method from the pattern will 
  cast the string to a value of appropriate type and append that value as a 
  token of a certain token type to the list. But it may also have any other 
  side effects. (For example changing the start condition of the lexer, see 
  below).
  
  Note, that the method can also append any other number of tokens to the list
  including none.
  
  There is one special action named 'dump'. When a rule with this action is
  matched, the token will simply be discarded.
  
  If a pattern does not have an action, it is considered to be an anonymous
  one. That means, when the lexer matches this pattern, it will append a
  terminal token of type String containing the matched string to the token
  list. Tokens produced by anonymous patterns can matched in grammer rules by
  simply reproducing the defining regular expression or string. Additionally,
  anonymous patterns that are defined by a regular expression, can have an
  optional default value, put in () after the expression. The default values
  are used during error recovery.
  
  Usages:
    [ < IDENTIFIER+ > ] REGEXP [ IDENTIFIER ] ;
    [ < IDENTIFIER+ > ] STRING [ IDENTIFIER ] ;
    [ < IDENTIFIER+ > ] REGEXP [ ( LITERAL ) ] ;

  Examples:
    /{ws}/	dump;
    ";";
    /_*[a-zA-Z_][a-zA-Z0-9_]*/	appendIdentifier;

3.Terminal declarations

  are used to declare the terminal symbols that will can be used in the 
  grammer besides the anonymous patterns (see above). Every terminal has a
  type (possibly "void") and a name (IDENTIFIER). The names are used in the
  grammer rules to reference the terminals. The type must be a valid C++
  type (a subset, actually) including template types. At the moment it must be
  a type member of your implementing class. Meaning you will have to use
  appropriate typedefs in order to "import" types from other name spaces. This
  limitation will propably be removed in the future.
  
  For each terminal, a corresponding append-method is created in the token
  list class. So for declarations like:
  
    void FOO;
    double NUMBER;
    
  the following methods would be generated:
  
    void appendFOO();
    void appendNUMBER(double val);
    
  They are supposed to be used within the methods called when patterns are
  matched.
  
  Like anonymous patterns, for the sake of error recovery, a default value for
  every terminal can be defined.
  
  Usage:
    [TYPE] IDENTIFIER [ ( LITERAL ) ] ;

4.Grammer rules
  (also "productions") are used to denote the actual grammer you want a parser
  generated for. They consist of a left side, giving a type and a nonterminal
  name, and one or more right sides seperated by |'s .
  Each right side in turn is made of a possibly empty list of terminal and 
  nonterminal names enclosed by a pair of parantheses. This list is optionally
  followed by an action introduced by a colon (:). Because each right side
  represents a reduction to the nonterminal symbol on the left at run time,
  a value matching the rule's type must be produced, or an existing one 
  re-used. If no action is given, the standard constructor of the rule's type
  will be employed for this purpose. Otherwise the supplied action is 
  responsible for this.
  There are three different types of actions.
  
    1.Call Actions
    
      Usage:
        : IDENTIFIER ( [arg1 [, arg2] ... ] )
        
      Call actions will invoke the method given by the IDENTIFIER with the 
      arguments from the argument list. The value returned by the method must
      be of the same type as the rule. 

    2.Constructer Actions
    
      Usage:
        : ( [arg1 [, arg2] ... ] )
        
      Constructer Actions invoke one of the constructors of therule's type with
      the supplied arguments.
      
    3.Re-use Actions
    
      Usage:
        : INTEGER [ IDENTIFIER ( [arg1 [, arg2] ... ] ) ]
        
      Re-use actions simply use the token identified by the INTEGER. 
      Consequently the terminal or nonterminal at this position must have the
      same type as the rule. This kind of call is very efficient, because no
      new list nodes have to be allocated.
      For the sake of side effects or pre-processing the selected value, an
      optional call action can folow the number. Its return type is irrelevant.
      
  



















Regular Expressions
===================

